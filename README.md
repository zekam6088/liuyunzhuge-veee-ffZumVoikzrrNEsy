[合集 - 技术札纪——有限硬件与无限计算的权衡艺术(49)](https://github.com)

[1.书本介绍：技术札纪——有限硬件与无限计算的权衡艺术07-24](https://github.com/poemyang/p/19002322)[2.书本大纲：从芯片、分布式到云计算AI时代07-25](https://github.com/poemyang/p/19004265)[3.我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？07-25](https://github.com/poemyang/p/19004704)[4.我的代码出现幻觉？说好的a = 1； x = b，怎么成了x = b； a = 1？07-28](https://github.com/poemyang/p/19008983)[5.为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”07-29](https://github.com/poemyang/p/19010948)[6.没有Happens-Before？你的多线程代码就是‘一锅粥’！07-30](https://github.com/poemyang/p/19012883)[7.Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法07-31](https://github.com/poemyang/p/19014740)[8.a+b=c，处理器一步搞定，Java虚拟机为啥要四步？08-01](https://github.com/poemyang/p/19016482)[9.“同声传译”还是“全文翻译”？为何HotSpot虚拟机仍要保留解释器？08-04](https://github.com/poemyang/p/19020937)[10.“代码跑着跑着，就变快了？”——揭秘Java性能幕后引擎：即时编译器08-05](https://github.com/poemyang/p/19022518)[11.Java编译器优化秘籍：字节码背后的IR魔法与常见技巧08-06](https://github.com/poemyang/p/19024509)[12.解锁硬件潜能：Java向量化计算，性能飙升W倍！08-07](https://github.com/poemyang/p/19026352)[13.new出来的对象，不一定在堆上？聊聊Java虚拟机的优化技术：逃逸分析08-08](https://github.com/poemyang/p/19027777)[14.性能优化之母：为什么说“方法内联”是编译器优化中最关键的一步棋？08-11](https://github.com/poemyang/p/19031406)[15.从纳秒到毫秒的“时空之旅”：CPU是如何看待内存与硬盘的？08-12](https://github.com/poemyang/p/19033086)[16.硬盘性能提升100倍的秘密：看懂顺序I/O的魔力08-14](https://github.com/poemyang/p/19038725)[17.十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解08-18](https://github.com/poemyang/p/19043960)[18.Facebook内部都在用的存储引擎，LSM凭什么能硬扛亿级写入流量？08-21](https://github.com/poemyang/p/19050442)[19.千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！08-22](https://github.com/poemyang/p/19052513)[20.RPC的三大问题：跨语言、跨平台通信的终极解决方案是如何炼成的？08-27](https://github.com/poemyang/p/19060527)[21.从文本到二进制：HTTP/2不止于性能，更是对HTTP/1核心语义的传承与革新08-28](https://github.com/poemyang/p/19061836)[22.从HPACK到多路复用，揭秘HTTP/2如何终结网络拥堵08-29](https://github.com/poemyang/p/19063734)[23.站在巨人的肩膀上：gRPC通过HTTP/2构建云原生时代的通信标准09-01](https://github.com/poemyang/p/19068100)[24.gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？09-03](https://github.com/poemyang/p/19071487):[veee加速器官网](https://youhaochi.com)[25.从JSON到Protobuf，深入序列化方案的选型与原理09-04](https://github.com/poemyang/p/19073206)[26.“卧槽，系统又崩了！”——别慌，这也许是你看过最通俗易懂的分布式入门09-05](https://github.com/poemyang/p/19074847)[27.海量数据如何“安家”？一文读懂哈希、范围和一致性哈希三大分片策略09-08](https://github.com/poemyang/p/19079520)[28.“你还活着吗？” “我没死，只是网卡了！”——来自分布式世界的“生死契约”09-09](https://github.com/poemyang/p/19082361)[29.“凭什么说你比我先？”——没有上帝时钟，如何判断“谁先谁后”？09-12](https://github.com/poemyang/p/19087563)[30.“鸡蛋不能放一个篮子里”，如何确保千亿数据万无一失？09-15](https://github.com/poemyang/p/19092154)[31.系统里数据又“打架”了？让“少数服从多数”来终结这场混乱！09-18](https://github.com/poemyang/p/19097975)[32.技术圈的“绯闻女孩”：Gossip是如何把八卦秘密传遍全网的？09-19](https://github.com/poemyang/p/19100196)[33.绯闻女孩不只会八卦：从“验明正身”到“抓内鬼”，Gossip的进阶玩法09-20](https://github.com/poemyang/p/19101931)[34.从混沌到秩序：Java共享内存模型如何通过显式约束驯服并发？09-23](https://github.com/poemyang/p/19106679)[35.一把锁的两种承诺：synchronized如何同时保证互斥与内存可见性？09-24](https://github.com/poemyang/p/19108676)[36.从MESA模型到锁升级：synchronized性能逆袭的底层逻辑09-25](https://github.com/poemyang/p/19110705)[37.揭秘JUC：volatile与CAS，并发编程的两大基石09-27](https://github.com/poemyang/p/19114881)[38.“不要通过共享内存来通信”——深入理解Golang并发模型与CSP理论10-13](https://github.com/poemyang/p/19139419)[39.Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？10-14](https://github.com/poemyang/p/19142146)[40.“一切皆文件”：揭秘LINUX I/O与虚拟内存的底层设计哲学10-15](https://github.com/poemyang/p/19143895)[41.你的程序为何卡顿？从LINUX I/O三大模式寻找答案10-16](https://github.com/poemyang/p/19146666)[42.单线程如何撑起百万连接？I/O多路复用：现代网络架构的基石10-17](https://github.com/poemyang/p/19148798)[43.从C10K到Reactor：事件驱动，如何重塑高并发服务器的网络架构10-20](https://github.com/poemyang/p/19153675)[44.职责分离的艺术：剖析主从Reactor模型如何实现极致的并发性能10-21](https://github.com/poemyang/p/19156356)[45.“化零为整”的智慧：内存池如何绕过系统调用和GC，构建性能的护城河10-22](https://github.com/poemyang/p/19159101)[46.jemalloc思想的极致演绎：深度解构Netty内存池的精妙设计与实现10-23](https://github.com/poemyang/p/19160579)[47.为什么Java/Python程序无需关心内存释放？揭秘垃圾回收（GC）的核心概念10-25](https://github.com/poemyang/p/19166120)[48.压缩指针：64位系统下，Java虚拟机是如何“偷”回4字节内存的？10-27](https://github.com/poemyang/p/19170159)

49.谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑10-29

收起

引用计数与可达性分析：谁死了，谁还活着？
垃圾回收，顾名思义，便是将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。在Java虚拟机的语境下，垃圾指的是死亡的对象所占据的堆空间。这里便涉及了一个关键的问题：如何辨别一个对象是存是亡？

**引用计数**
引用计数（Reference Counting）是一种古老的辨别方法，它的基本思想是给每个对象添加一个引用计数器，每当有一个引用指向该对象时，计数器就加1；每当有一个引用停止指向该对象时，计数器就减1。当计数器的值变为0时，就表示没有任何引用指向该对象，因此该对象就成为垃圾，
引用计数的主要问题是无法处理循环引用（Reference Cycle）的情况。例如，如果对象A和对象B互相引用，那么即使没有其他引用指向它们，它们的引用计数器也不会变为0，因此它们不会被回收，这就导致了内存泄漏。这是引用计数最大的缺点，也是它在许多现代编程语言中不被使用的主要原因。
![image](https://img2024.cnblogs.com/blog/757914/202510/757914-20251029000719846-380860519.png)

另外，引用计数需要在每次引用赋值时更新引用计数器，这会带来一定的性能开销。而且，如果多个线程同时修改同一个对象的引用计数器，还需要进行同步，这会进一步增加性能开销。

**可达性分析**
Java虚拟机的主要采取的是可达性分析（Reachability Analysis）。这个算法是通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
GC Roots通常是由堆外指向堆内的引用，包括以下几种。
1）虚拟机栈（栈帧中的本地变量表）中引用的对象；
2）方法区中类静态属性引用的对象；
3）方法区中常量引用的对象；
4）本地方法栈中JNI（即一般说的Native方法）引用的对象。
![image](https://img2024.cnblogs.com/blog/757914/202510/757914-20251029000730264-853086319.png)

可达性分析可以解决引用计数所不能解决的循环引用问题。例如，即便对象A和B相互引用，只要从GC Roots出发无法到达A或者B，那么可达性分析便不会将它们加入存活对象合集之中。
尽管可达性分析的算法本身很直观，但在实际应用中，还需要解决一些其他问题，如误标和漏标。
1）误标：将已经不再使用的对象错误地标记为"活的"。例如，一个全局静态对象引用了一个已经不再需要的局部对象，它会被错误地标记为"活的"。
2）漏标：将仍在使用的对象错误地标记为"死的"。例如，在并发环境中，一个线程正在使用一个对象，而另一个线程正在进行垃圾回收。如果垃圾回收线程看到的是一个过时的对象引用关系，它可能会错误地认为一个正在使用的对象是"死的"。
误报可能导致Java虚拟机错过部分垃圾回收的机会。而漏报更麻烦，因为垃圾回收器可能会错误地回收仍被引用的对象内存。如果试图从原引用访问已经被回收的对象，可能会导致Java虚拟机崩溃。

**Stop-the-world 以及安全点**
为了避免这些问题，Java虚拟机的传统垃圾回收算法采用了Stop-the-world方式。在此阶段，Java虚拟机会暂停所有的应用线程，确保在垃圾回收过程中不会有新的对象被创建，也不会有对象引用关系的变化。但这会导致应用程序的响应时间增加，因为在这个阶段，所有的应用线程都被暂停，应用程序无法响应用户的请求。
安全点（Safe Point）是Java虚拟机用来控制Stop-the-World的一种机制。安全点是指那些可以安全地暂停应用线程的点。在这些点上，Java虚拟机可以确保对象引用关系不会发生变化。常见的安全点有方法调用（包括JNI方法调用）、循环跳转、异常抛出等。其中方法调用是一个很好的安全点，因为方法调用通常涉及到大量的对象引用操作。
对于解释执行，当有安全点请求时，Java虚拟机可以在每条字节码指令后面都设置一个安全点，但这种方式的开销很大。在执行即时编译器生成的机器码时，Java虚拟机通常会在方法的入口和退出处，以及循环的回边处设置安全点。另外当线程阻塞时，由于处于Java虚拟机线程调度器的掌控之下，因此可以设置安全点。

**未完待续**

**很高兴与你相遇！如果你喜欢本文内容，记得关注哦**
